# 26. Remove Duplicates from Sorted Array 풀이

## 목차

1. [문제 요약](#1-문제-요약)
2. [풀이 1: Set + Stream API](#2-풀이-1-set--stream-api)
3. [풀이 2: Two Pointers (In-place)](#3-풀이-2-two-pointers-in-place)
4. [동작 과정 시각화](#4-동작-과정-시각화)
5. [비교 요약표](#5-비교-요약표)
6. [핵심 포인트](#6-핵심-포인트)

---

## 1. 문제 요약

| 항목     | 내용                                                              |
| -------- | ----------------------------------------------------------------- |
| **입력** | 오름차순 정렬된 정수 배열 `nums`                                  |
| **출력** | 고유 원소 개수 `k`                                                |
| **조건** | In-place로 수정, 앞 `k`개에 고유 원소가 정렬된 순서로 위치해야 함 |
| **제약** | `1 <= nums.length <= 3 * 10^4`, `-100 <= nums[i] <= 100`          |

---

## 2. 풀이 1: Set + Stream API

### 코드

```java
public int removeDuplicates(int[] nums) {
    Set<Integer> set = Arrays.stream(nums).boxed().collect(Collectors.toSet());
    int i = 0;
    for (Integer num : set.stream().sorted().toList()) {
        nums[i] = num;
        i++;
    }
    return set.size();
}
```

### 사용 자료구조

| 자료구조    | 역할                                      |
| ----------- | ----------------------------------------- |
| **HashSet** | 중복 제거를 위한 집합 자료구조            |
| **Stream**  | 배열 → Set 변환, 정렬 후 다시 배열에 기록 |

### 동작 원리

```
1단계: 배열 → Stream → Set (중복 자동 제거)
   nums = [-3, -1, 0, 0, 0, 3, 3]
   set  = {-3, -1, 0, 3}           ← 순서 보장 X

2단계: Set → Stream → sorted() → 배열에 다시 기록
   sorted = [-3, -1, 0, 3]
   nums   = [-3, -1, 0, 3, 0, 3, 3]  ← 앞 4개만 유효
```

### 복잡도 분석

| 항목     | 복잡도         | 설명                            |
| -------- | -------------- | ------------------------------- |
| **시간** | **O(n log n)** | Set 생성 O(n) + 정렬 O(n log n) |
| **공간** | **O(n)**       | HashSet에 최대 n개 원소 저장    |

### 장단점

- **장점**: 직관적이고 이해하기 쉬움, Java Stream API 활용 연습에 좋음
- **단점**: 불필요한 추가 메모리 사용, 이미 정렬된 배열을 다시 정렬하는 비효율, Boxing/Unboxing 오버헤드 (`int` ↔ `Integer`)

---

## 3. 풀이 2: Two Pointers (In-place)

### 코드

```java
public int removeDuplicates2(int[] nums) {
    int lt = 0;
    for (int rt = 1; rt < nums.length; rt++) {
        if (nums[lt] != nums[rt]) {
            lt++;
            nums[lt] = nums[rt];
        }
    }
    return lt + 1;
}
```

### 사용 자료구조

| 자료구조                  | 역할                                              |
| ------------------------- | ------------------------------------------------- |
| **int 변수 2개 (lt, rt)** | 원본 배열 위에서 직접 포인터를 이동하며 중복 제거 |

### 동작 원리

- `lt` (left): 고유 원소가 채워질 위치를 가리킴
- `rt` (right): 배열을 순회하며 새로운 값을 탐색
- `nums[lt] != nums[rt]`일 때만 `lt`를 전진시키고 값을 복사

> **핵심**: 입력 배열이 이미 정렬되어 있으므로, 인접한 원소만 비교하면 중복을 판별할 수 있다.

### 복잡도 분석

| 항목     | 복잡도   | 설명                                      |
| -------- | -------- | ----------------------------------------- |
| **시간** | **O(n)** | 배열을 한 번만 순회                       |
| **공간** | **O(1)** | 추가 자료구조 없이 포인터 변수 2개만 사용 |

### 장단점

- **장점**: 최적의 시간/공간 복잡도, In-place 수정으로 메모리 효율적, 문제 조건(정렬된 배열)을 최대한 활용
- **단점**: 포인터 이동 로직에 대한 이해 필요

---

## 4. 동작 과정 시각화

### 입력: `[-3, -1, 0, 0, 0, 3, 3]`

### 풀이 1 (Set + Stream)

```
원본 배열    → [-3, -1, 0, 0, 0, 3, 3]
                        ↓ Arrays.stream().boxed().collect(toSet())
HashSet      → {0, -1, 3, -3}              ← 순서 보장 X
                        ↓ stream().sorted().toList()
정렬된 리스트 → [-3, -1, 0, 3]
                        ↓ nums[i] = num
결과 배열    → [-3, -1, 0, 3, 0, 3, 3]     ← k = 4
```

### 풀이 2 (Two Pointers)

```
초기 상태:
[-3, -1, 0, 0, 0, 3, 3]
  lt  rt

Step 1: nums[0]=-3 ≠ nums[1]=-1 → lt++, nums[1]=-1
[-3, -1, 0, 0, 0, 3, 3]
      lt  rt

Step 2: nums[1]=-1 ≠ nums[2]=0 → lt++, nums[2]=0
[-3, -1, 0, 0, 0, 3, 3]
          lt  rt

Step 3: nums[2]=0 == nums[3]=0 → skip
[-3, -1, 0, 0, 0, 3, 3]
          lt      rt

Step 4: nums[2]=0 == nums[4]=0 → skip
[-3, -1, 0, 0, 0, 3, 3]
          lt         rt

Step 5: nums[2]=0 ≠ nums[5]=3 → lt++, nums[3]=3
[-3, -1, 0, 3, 0, 3, 3]
              lt      rt

Step 6: nums[3]=3 == nums[6]=3 → skip
[-3, -1, 0, 3, 0, 3, 3]
              lt         rt (종료)

결과: k = lt + 1 = 4
[-3, -1, 0, 3, -, -, -]    ← 앞 4개가 고유 원소
```

---

## 5. 비교 요약표

| 비교 항목           | 풀이 1 (Set + Stream)             | 풀이 2 (Two Pointers)             |
| ------------------- | --------------------------------- | --------------------------------- |
| **자료구조**        | HashSet, Stream, List             | 원본 배열 + 포인터 변수 2개       |
| **시간 복잡도**     | O(n log n)                        | **O(n)**                          |
| **공간 복잡도**     | O(n)                              | **O(1)**                          |
| **In-place 여부**   | X (추가 Set 생성)                 | **O (원본 배열 직접 수정)**       |
| **정렬 조건 활용**  | X (Set은 순서를 잃어 재정렬 필요) | **O (정렬된 상태를 그대로 활용)** |
| **Boxing 오버헤드** | O (`int` → `Integer`)             | X (원시 타입 그대로 사용)         |
| **코드 가독성**     | 직관적, Stream 친화적             | 간결하지만 포인터 이해 필요       |
| **실무 적합도**     | 작은 데이터에서 사용 가능         | **대용량 데이터에 적합**          |

---

## 6. 핵심 포인트

### 왜 Two Pointers가 더 적합한가?

1. **문제의 전제 조건 활용**: 배열이 이미 **정렬**되어 있으므로, 인접한 원소만 비교하면 중복을 판별할 수 있다. Set으로 중복을 제거한 뒤 다시 정렬하는 것은 이 조건을 버리는 것과 같다.

2. **In-place 요구사항 충족**: 문제가 명시적으로 In-place 수정을 요구한다. Set 풀이는 O(n) 추가 공간을 사용하므로 엄밀히는 이 조건을 위반한다.

3. **성능 차이**: n이 최대 30,000일 때, O(n) vs O(n log n)의 차이가 발생하며, 메모리 할당 및 GC 부담도 줄어든다.

### Two Pointers 패턴이 자주 쓰이는 문제 유형

| 유형                     | 예시 문제                                        |
| ------------------------ | ------------------------------------------------ |
| **중복 제거**            | LeetCode 26, 80                                  |
| **정렬된 배열에서 탐색** | LeetCode 167 (Two Sum II)                        |
| **부분 배열/윈도우**     | LeetCode 3 (Longest Substring Without Repeating) |
| **병합**                 | LeetCode 88 (Merge Sorted Array)                 |
| **회문 판별**            | LeetCode 125 (Valid Palindrome)                  |

### 기억할 것

> **정렬된 배열** + **In-place 수정** 조합이 보이면, **Two Pointers**를 우선적으로 고려하자.
