# 가장 많이 받은 선물 - 풀이 정리

## 목차

1. [출제 의도](#1-출제-의도)
2. [핵심 자료구조](#2-핵심-자료구조)
3. [풀이 흐름](#3-풀이-흐름)
4. [두 풀이 비교](#4-두-풀이-비교)
5. [모범 답안 복잡도](#5-모범-답안-복잡도)
6. [핵심 포인트](#6-핵심-포인트)

---

## 1. 출제 의도

이 문제는 **구현/시뮬레이션** 유형이다. 복잡한 알고리즘이 아닌, 주어진 규칙을 정확히 코드로 옮길 수 있는지를 평가한다.

| 테스트 역량 | 설명 |
|-------------|------|
| **자료구조 설계** | 친구 간 선물 교환 관계를 어떤 구조로 저장할 것인가 |
| **조건 분기 처리** | 3단계 우선순위 규칙(교환 기록 > 선물 지수 > 무시)을 빠짐없이 구현 |
| **문자열 → 인덱스 매핑** | 이름(String)을 효율적으로 다루기 위한 HashMap 활용 |

---

## 2. 핵심 자료구조

| 자료구조 | 용도 | 코드에서의 형태 |
|----------|------|----------------|
| **HashMap** | 이름 → 인덱스 매핑 | `Map<String, Integer> nameMap` |
| **2D 배열 (인접 행렬)** | i가 j에게 준 선물 횟수 | `int[][] giftMatrix` |
| **1D 배열** | 선물 지수 (준 횟수 - 받은 횟수) | `int[] giftIndex` |
| **1D 배열** | 다음 달 받을 선물 수 | `int[] nextMonthGifts` |

### 왜 2D 인접 행렬인가?

"A가 B에게 준 선물 횟수"처럼 **두 사람 간의 방향성 있는 관계**를 저장해야 한다.
`giftMatrix[i][j]`는 i가 j에게 준 선물 수를 의미하며, `giftMatrix[j][i]`는 그 반대이므로 비교가 O(1)에 가능하다.

```
         받은 사람 →
          muzi  ryan  frodo  neo
준 muzi  [  -     0     2     0  ]
사 ryan  [  3     -     0     0  ]
람 frodo [  1     1     -     0  ]
↓ neo   [  1     0     0     -  ]
```

---

## 3. 풀이 흐름

```
1. 이름 → 인덱스 매핑 (HashMap)
2. gifts 파싱 → 2D 행렬 채우기 + 선물 지수 계산
3. 모든 쌍(i, j)에 대해 규칙 적용:
   ┌─ giftMatrix[i][j] > giftMatrix[j][i]  →  i가 선물 받음
   ├─ 같으면 giftIndex[i] > giftIndex[j]   →  i가 선물 받음
   └─ 그것도 같으면                          →  아무도 안 받음
4. 최대값 반환
```

---

## 4. 두 풀이 비교

### solution: 선물 지수를 별도 이중 루프로 계산

```java
// 주고받은 선물 내역 저장
for (String gift : gifts) {
    String[] arr = gift.split(" ");
    array[nameMap.get(arr[0])][nameMap.get(arr[1])] += 1;
}
// 선물 지수: 별도 이중 루프로 행/열 합산
for (int i = 0; i < count; i++) {
    int give = 0, receive = 0;
    for (int j = 0; j < count; j++) {
        give += array[i][j];      // 행 합산 (내가 준 총합)
        receive += array[j][i];   // 열 합산 (내가 받은 총합)
    }
    index[i] = give - receive;
}
```

### solution2: gifts 파싱 시 선물 지수 동시 계산

```java
for (String gift : gifts) {
    String[] giftArray = gift.split(" ");
    int from = nameMap.get(giftArray[0]);
    int to = nameMap.get(giftArray[1]);
    giftMatrix[from][to] += 1;
    giftIndex[from]++;   // 준 사람 +1
    giftIndex[to]--;     // 받은 사람 -1
}
```

### 차이점

| 비교 항목 | solution | solution2 |
|-----------|----------|-----------|
| **선물 지수 계산** | 별도 이중 루프 O(n²) | gifts 파싱 시 동시 계산 |
| **최대값 반환** | 수동 for 루프 | `Arrays.stream().max()` |
| **불필요한 루프** | 선물 지수용 이중 루프 1개 추가 | 없음 |
| **코드 간결성** | 단계가 분리되어 명확 | 루프 하나 줄여 더 효율적 |

> 두 풀이 모두 점근적 시간 복잡도는 동일하지만, solution2가 상수 시간에서 더 효율적이다.

---

## 5. 모범 답안 복잡도

| 항목 | 복잡도 | 설명 |
|------|--------|------|
| **시간** | **O(n² + g)** | n = 친구 수(최대 50), g = 선물 기록 수(최대 10,000) |
| **공간** | **O(n²)** | 2D 인접 행렬이 지배적 |

### 세부 분석

```
1단계: 이름 매핑          → O(n)
2단계: gifts 파싱 + 행렬  → O(g)
3단계: 모든 쌍 비교       → O(n²)
4단계: 최대값 탐색        → O(n)
────────────────────────────────
합계: O(n² + g)
```

n ≤ 50이므로 n² = 2,500, g ≤ 10,000이므로 전체적으로 매우 여유롭다.
Lv.1 답게 **효율성보다 정확한 구현**이 관건이다.

---

## 6. 핵심 포인트

### 이 문제에서 기억할 패턴

> **"두 사람 간의 관계 데이터"** 가 등장하면 → **2D 인접 행렬**로 모델링하라.

> **"문자열 키를 인덱스로 변환"** 해야 하면 → **HashMap\<String, Integer\>** 매핑을 먼저 만들어라.

### 자주 하는 실수

| 실수 | 설명 |
|------|------|
| **대칭 비교 누락** | `giftMatrix[i][j]`와 `giftMatrix[j][i]`를 동시에 비교해야 함 |
| **조건 우선순위 무시** | 교환 기록 비교 → 선물 지수 비교 → 무시, 순서가 중요함 |
| **선물 지수 부호 오류** | `준 선물 - 받은 선물`이며, 음수가 될 수 있음 |
| **자기 자신 비교** | `i == j`인 경우를 건너뛰어야 함 |
