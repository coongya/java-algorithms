# 멋쟁이 숫자 - 풀이 정리

## 목차

1. [출제 의도](#1-출제-의도)
2. [풀이 1: substring + parseInt](#2-풀이-1-substring--parseint)
3. [풀이 2: charAt - '0' + * 111](#3-풀이-2-charat---0---111)
4. [핵심 개념 설명](#4-핵심-개념-설명)
5. [비교 요약표](#5-비교-요약표)
6. [핵심 포인트](#6-핵심-포인트)

---

## 1. 출제 의도

2022 토스 NEXT 코딩테스트 기출 (만점자 1,435명, 최저 난이도 문제)

| 테스트 역량 | 설명 |
|-------------|------|
| **문자열 순회** | 슬라이딩 윈도우로 길이 3인 substring을 탐색할 수 있는가 |
| **조건 판별** | 세 자리가 모두 같은 숫자인지 판별할 수 있는가 |
| **엣지 케이스 처리** | `"000"` → 0, 멋쟁이 숫자 없음 → -1 |

---

## 2. 풀이 1: substring + parseInt

### 코드

```java
public int fancyNumber(String s) {
    int max = -1;
    for (int i = 0; i < s.length() - 2; i++) {
        if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i + 1) == s.charAt(i + 2)) {
            max = Math.max(max, Integer.parseInt(s.substring(i, i + 3)));
        }
    }
    return max;
}
```

### 동작 원리

```
s = "111999333"

i=0: "111" → 세 자리 동일 → parseInt("111") = 111 → max = 111
i=1: "119" → X
i=2: "199" → X
i=3: "999" → 세 자리 동일 → parseInt("999") = 999 → max = 999
i=4: "993" → X
i=5: "933" → X
i=6: "333" → 세 자리 동일 → parseInt("333") = 333 → 333 < 999 → skip

결과: 999
```

### 복잡도

| 항목 | 복잡도 | 설명 |
|------|--------|------|
| **시간** | **O(n)** | 문자열을 한 번 순회 |
| **공간** | **O(1)** | 고정된 변수만 사용 (substring 임시 객체 제외) |

---

## 3. 풀이 2: charAt - '0' + * 111

### 코드

```java
public int fancyNumber2(String s) {
    int max = -1;
    for (int i = 0; i < s.length() - 2; i++) {
        if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i + 1) == s.charAt(i + 2)) {
            max = Math.max(max, (s.charAt(i) - '0') * 111);
        }
    }
    return max;
}
```

### 동작 원리

```
s = "111999333", i=3일 때

s.charAt(3)              → '9'  (char, ASCII 57)
s.charAt(3) - '0'        → 57 - 48 = 9  (int, 실제 숫자)
(s.charAt(3) - '0') * 111 → 9 * 111 = 999  (멋쟁이 숫자!)
```

### 복잡도

| 항목 | 복잡도 | 설명 |
|------|--------|------|
| **시간** | **O(n)** | 문자열을 한 번 순회 |
| **공간** | **O(1)** | 객체 생성 없이 산술 연산만 사용, 진정한 O(1) |

---

## 4. 핵심 개념 설명

### 4-1. `charAt() - '0'`: 문자 → 숫자 변환

Java에서 `char`는 내부적으로 ASCII 코드(정수)로 저장된다.

```
문자    ASCII 코드
'0'  →  48
'1'  →  49
'2'  →  50
 ...
'9'  →  57
```

`'0'`~`'9'`는 **연속된 코드값**이므로, `'0'`을 빼면 실제 숫자를 얻는다.

```
'9' - '0'  =  57 - 48  =  9
'5' - '0'  =  53 - 48  =  5
'0' - '0'  =  48 - 48  =  0
```

> Java/C/C++에서 **문자 → 숫자 변환의 표준 관용구**이다.

### 4-2. `* 111`: 멋쟁이 숫자 복원

멋쟁이 숫자는 세 자리가 모두 같은 숫자 `d`이므로:

```
d × 100 + d × 10 + d × 1  =  d × (100 + 10 + 1)  =  d × 111
```

| d | d × 111 | 멋쟁이 숫자 |
|---|---------|------------|
| 0 | 0 | 000 → 0 |
| 1 | 111 | 111 |
| 2 | 222 | 222 |
| ... | ... | ... |
| 9 | 999 | 999 |

### 4-3. 풀이 1 vs 풀이 2 — 같은 위치에서 무슨 일이 일어나는가

```java
// 풀이 1: 문자열 생성 + 파싱
Integer.parseInt(s.substring(i, i + 3))
//              └─ 새 String 객체 힙 할당 ("999")
//  └─ 문자열 파싱: '9','9','9' → 9*100 + 9*10 + 9 = 999

// 풀이 2: 산술 연산만
(s.charAt(i) - '0') * 111
// └─ 뺄셈 1회       └─ 곱셈 1회
// 힙 할당 없음, 파싱 없음
```

---

## 5. 비교 요약표

| 비교 항목 | 풀이 1 (substring + parseInt) | 풀이 2 (charAt - '0' + * 111) |
|-----------|-------------------------------|-------------------------------|
| **시간 복잡도** | O(n) | O(n) |
| **공간 복잡도** | O(1) (substring 임시 객체 제외) | **진정한 O(1)** |
| **루프 내 핵심 연산** | `substring()` + `parseInt()` | 뺄셈 + 곱셈 |
| **힙 할당** | 매 매칭마다 String 생성 | 없음 |
| **가독성** | 직관적 | `- '0'`, `* 111` 이해 필요 |
| **엣지 케이스** | `parseInt("000")` = 0 자동 처리 | `0 * 111` = 0 자동 처리 |

---

## 6. 핵심 포인트

### 기억할 패턴

> **문자 → 숫자 변환**이 필요하면 `charAt() - '0'`을 사용하라. `Character.getNumericValue()`보다 가볍고 코딩테스트에서 표준 관용구이다.

> **반복되는 자릿수 계산**은 곱셈으로 대체할 수 있다. 같은 숫자 n자리 = `d × (10^(n-1) + 10^(n-2) + ... + 1)` (예: 3자리 → `d × 111`, 4자리 → `d × 1111`)

### 엣지 케이스 체크리스트

| 입력 | 기대값 | 설명 |
|------|--------|------|
| `"12223"` | 222 | 기본 케이스 |
| `"111999333"` | 999 | 여러 멋쟁이 숫자 중 최대값 |
| `"123"` | -1 | 멋쟁이 숫자 없음 |
| `"000123"` | 0 | "000"이 최대 멋쟁이 숫자 |
| `""` | -1 | 빈 문자열 |
